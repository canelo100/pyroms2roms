# -*- coding: utf-8 -*-
# %run pycfsr2frc.py

'''
Create a forcing file based on CFSR data


E. Mason IMEDEA 2012
'''

import netCDF4 as netcdf
import pylab as plt
import numpy as np
from scipy import io
import scipy.interpolate as si
import scipy.ndimage as nd
import scipy.spatial as sp
import matplotlib.nxutils as nx
import time
import scipy.interpolate.interpnd as interpnd
#import collections
from mpl_toolkits.basemap import Basemap
from collections import OrderedDict
from datetime import datetime
import calendar as ca

from pyroms2roms import horizInterp
from pyroms2roms import ROMS, debug0, debug1
from pyroms2roms import RomsGrid, RomsData



class RomsGrid(RomsGrid):
    '''
    Modify the RomsGrid class
    '''
    
    def create_frc_nc(self, frcfile, sd, ed, nr, cl, madeby):
        '''
        Create a new forcing file based on dimensions from grdobj
            frcfile : path and name of new frc file
            sd      : start date2num
            ed      : end date
            nr      : no. of records
            cl      : cycle length
            madeby  : name of this file
        '''
        self.frcfile = frcfile
        print 'Creating new CFSR forcing file', frcfile
        # Global attributes
        ''' The best choice should be format='NETCDF4', but it will not work with
        Sasha's 2008 code (not tested with Roms-Agrif).  Therefore I use
        format='NETCDF3_64BIT; the drawback is that it is very slow'
        '''
        #nc = netcdf.Dataset(frcfile, 'w', format='NETCDF3_64BIT')
        nc = netcdf.Dataset(frcfile, 'w', format='NETCDF3_CLASSIC')
        #nc = netcdf.Dataset(frcfile, 'w', format='NETCDF4')
        nc.created  = datetime.now().isoformat()
        nc.type = 'ROMS interannual forcing file produced by %s.py' %madeby
        nc.grd_file = self.romsfile
        nc.start_date = sd
        nc.end_date = ed
        
        # Dimensions
        nc.createDimension('xi_rho', self.lon().shape[1])
        nc.createDimension('xi_u', self.lon().shape[1] - 1)
        nc.createDimension('eta_rho', self.lon().shape[0])
        nc.createDimension('eta_v', self.lon().shape[0] - 1)
        nc.createDimension('sms_time', nr)
        nc.createDimension('shf_time', nr)
        nc.createDimension('swf_time', nr)
        nc.createDimension('sst_time', nr)
        nc.createDimension('srf_time', nr)
        nc.createDimension('sss_time', nr)
        nc.createDimension('one', 1)
        

        # Dictionary for the variables
        frc_vars = OrderedDict()
        
        frc_vars['sms_time'] = ['time',
                                'sms_time',
                                'surface momentum stress time',
                                'days']
        frc_vars['shf_time'] = ['time',
                                'shf_time',
                                'surface heat flux time',
                                'days']
        frc_vars['swf_time'] = ['time',
                                'swf_time',
                                'surface freshwater flux time',
                                'days']
        frc_vars['sst_time'] = ['time',
                                'sst_time',
                                'sea surface temperature time',
                                'days']
        frc_vars['sss_time'] = ['time',
                                'sss_time',
                                'sea surface salinity time',
                                'days']
        frc_vars['srf_time'] = ['time',
                                'srf_time',
                                'solar shortwave radiation time',
                                'days']
        
        # Note this could be problematic if scale_cfsr_coads.py adjusts variables
        # with different frequencies...
        frc_vars['month']    = ['time',
                                'sst_time',
                                'not used by ROMS; useful for scale_cfsr_coads.py',
                                'month of year']
        
        
        frc_vars['sustr'] =  ['u',
                              'sms_time',
                              'surface u-momentum stress',
                              'Newton meter-2']
        frc_vars['svstr'] =  ['v',
                              'sms_time',
                              'surface v-momentum stress',
                              'Newton meter-2']
        frc_vars['shflux'] = ['rho',
                              'shf_time',
                              'surface net heat flux',
                              'Watts meter-2']
        frc_vars['swflux'] = ['rho',
                              'swf_time',
                              'surface freshwater flux (E-P)',
                              'centimeters day-1',
                              'net evaporation',
                              'net precipitation']
        frc_vars['SST'] =    ['rho',
                              'sst_time',
                              'sea surface temperature',
                              'Celsius']
        frc_vars['SSS'] =    ['rho',
                              'sss_time',
                              'sea surface salinity',
                              'PSU']
        frc_vars['dQdSST'] = ['rho',
                              'sst_time',
                              'surface net heat flux sensitivity to SST',
                              'Watts meter-2 Celsius-1']
        frc_vars['swrad'] =  ['rho',
                              'srf_time',
                              'solar shortwave radiation',
                              'Watts meter-2',
                              'downward flux, heating',
                              'upward flux, cooling']
        
        
        for key, value in zip(frc_vars.keys(), frc_vars.values()):

            #print key, value

            if 'time' in value[0]:
                dims = (value[1])

            elif 'rho' in value[0]:
                dims = (value[1], 'eta_rho', 'xi_rho')

            elif 'u' in value[0]:
                dims = (value[1], 'eta_rho', 'xi_u')
                    
            elif 'v' in value[0]:
                dims = (value[1], 'eta_v', 'xi_rho')
                
            else:
                error
            
            #print 'key dims',key, dims
            nc.createVariable(key, 'f8', dims)
            nc.variables[key].long_name = value[2]
            nc.variables[key].units = value[3]
            
            if 'time' in key:
                nc.variables[key].cycle_length = cl
            
            if 'swrad' in key:
                nc.variables[key].positive = value[4]
                nc.variables[key].negative = value[5]
                
            if 'swflux' in key:
                nc.variables[key].positive = value[4]
                nc.variables[key].negative = value[5]

        nc.close()


    def gc_dist(self, lon1, lat1, lon2, lat2):
        '''
        Use Haversine formula to calculate distance
        between one point and another
        '''
        r_earth = 6371315. # Mean earth radius in metres (from scalars.h)
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        dang = 2. * np.arcsin(np.sqrt(np.power(np.sin(0.5 * dlat),2) + \
                      np.cos(lat2) * np.cos(lat1) * np.power(np.sin(0.5 * dlon),2)))
        return r_earth * dang # distance
            
            
            



    def get_runoff(self, swflux_data, dai_file, mon):
        '''
        
        '''
        mon -= 1
        area = 1. / (self.pm() * self.pn())
        dx = 1. / np.mean(self.pm())
 
        cdist = io.loadmat(self.roms_dir + 'coast_distances.mat')
        mask = self.mask()
        
        # Exponential decay, runoff forced towards coast.  75km ?
        mult = np.exp(-cdist['cdist'] / 150e4)
        np.place(mult, mask > 1., 0)

        # Read in river data and set data trim
        lon0 = np.round(self.lon().min() - 1.0)
        lon1 = np.round(self.lon().max() + 1.0)
        lat0 = np.round(self.lat().min() - 1.0)
        lat1 = np.round(self.lat().max() + 1.0)

        nc = netcdf.Dataset(dai_file)
        lon_runoff = nc.variables['lon'][:]
        lat_runoff = nc.variables['lat'][:]

        i0 = np.nonzero(lon_runoff > lon0)[0].min()
        i1 = np.nonzero(lon_runoff < lon1)[0].max() + 1
        j0 = np.nonzero(lat_runoff > lat0)[0].min()
        j1 = np.nonzero(lat_runoff < lat1)[0].max() + 1

        flux_unit = 1.1574e-07 # (cm/day)

        surf_ro = np.zeros(self.lon().shape)

        lon_runoff = lon_runoff[i0:i1]
        lat_runoff = lat_runoff[j0:j1]

        runoff = nc.variables['runoff'][mon, j0:j1, i0:i1]
        nc.close()
        
        lon_runoff, lat_runoff = np.meshgrid(lon_runoff, lat_runoff)
        lon_runoff = lon_runoff[runoff >= 1e-5]
        lat_runoff = lat_runoff[runoff >= 1e-5]
        runoff = runoff[runoff >= 1e-5]
        n_runoff = runoff.size
   
        for idx in np.arange(n_runoff):
      
            #print idx, n_runoff

            # Find suitable unmasked grid points to distribute run-off
            dist = self.gc_dist(np.deg2rad(self.lon()),
                                np.deg2rad(self.lat()),
                                np.deg2rad(lon_runoff[idx]),
                                np.deg2rad(lat_runoff[idx]))
        
            if dist.min() <= 5. * dx:
                scale = 150. * 1e3 # scale of Dai data is at 1 degree
                bool_mask = np.logical_and(dist < scale, mask > 0)
                int_are = np.sum(area[bool_mask])
                ave_wgt = np.mean(mult[bool_mask])

                surface_flux = 1e6 * runoff[idx] / int_are
                surf_ro[bool_mask] = surf_ro[bool_mask] + surface_flux / \
                                     flux_unit * mult[bool_mask] / ave_wgt

        return (swflux_data * mask) - (surf_ro * mask)











class CfsrGrid(RomsGrid):
    '''
    CFSR grid class (inherits from RomsGrid class)
    '''
    
    def _lonlat(self):
        lon = self.read_nc('lon', indices='[:]')
        lat = self.read_nc('lat', indices='[:]')
        return np.meshgrid(lon, lat[::-1])
    
    def lon(self):
        return self._lonlat()[0]
    
    def lat(self):
        return self._lonlat()[1]
    
    
    
    
    def metrics(self):
        '''
        Return array of metrics unique to this grid
          (lonmin, lonmax, lon_res, latmin, latmax, lat_res)
          where 'res' is resolution in degrees
        '''
        met = np.array([])
        lon_range = self.read_nc_att('lon', 'valid_range')
        lat_range = self.read_nc_att('lat', 'valid_range')
        
        lon_res = np.diff(lon_range) / self.lon().shape[1]
        lat_res = np.diff(lat_range) / self.lat().shape[0]
        
        met = np.concatenate((lon_range, lon_res, lat_range, lat_res))
        return met
    
    
    def select_mask(self, grids, masks):
        '''
        
        '''
        for gind, grid in enumerate(grids):
            if np.alltrue(grid.metrics() == self.metrics()):
                mask = masks[gind]
        try:
            return mask.get_mask()
        except Exception, err:
            print 'Unspecified grid in method "select_mask"'
            to_do__make_routine_to_add_new_grid_on_the_fly
        
        
    def resolution(self):
        '''
        Return the resolution of the data in degrees
        '''
        return self.metrics()[-1]
    
    
    def get_points(self, roms_M):
        '''
        get points
        '''
        return self.proj2gnom(roms_M)
                        
        


    def get_points_kdetree(self, roms_M):
        '''
        Check that no ROMS data points lie outside of the
        CFSR domain. If this occurs pycfsr2frc cannot function;
        the solution is to obtain a new CFSR file making sure it
        covers the child grid...
        '''
        cfsr_points_all = self.get_points(roms_M) # must use roms_M
        
        cfsr_tri = sp.Delaunay(cfsr_points_all) # triangulate full parent 
        tn = cfsr_tri.find_simplex(roms_points)
        assert not np.any(tn == -1), 'ROMS data points outside CFSR domain detected'
        
        # create cfsr grid KDE tree...
        cfsr_tree = sp.KDTree(cfsr_points_all)
        # ... in order to get minimum no. indices for interpolation.
        
        return cfsr_tree, cfsr_points_all



    def assert_resolution(self, cfsrgrd_tmp, key):
        '''
        
        '''
        assert self.metrics()[2] <= cfsrgrd_tmp.metrics()[2], \
            'Resolution of %s is lower than previous grids, move up in dict "cfsr_files"' %key





class CfsrData(RomsData):
    '''
    CFSR data class (inherits from RomsData class)
    '''
    
    def frc_emp(self, ind):
        '''
        evaporation minus precipitation in cm/day
        '''
        return self.read_nc('EMNP_L1', '[' + str(ind) + ']')[::-1]
    
        
    def frc_sat(self, ind):
        '''
        air temperature (K)
        '''
        try:
            return self.read_nc('TMP_L103_Avg', '[' + str(ind) + ']')[::-1]
        except Exception:
            return self.read_nc('TMP_L103', '[' + str(ind) + ']')[::-1]
    
    
    def frc_sap(self, ind):
        '''
        surface air pressure (Pa)
        '''
        try:
            return self.read_nc('PRES_L1', '[' + str(ind) + ']')[::-1]
        except Exception:
            return self.read_nc('PRES_L1_Avg', '[' + str(ind) + ']')[::-1]
        
    def frc_sss(self, ind):
        '''
        sea surface salinity (kg kg-1)
        '''
        return self.read_nc('SALTY_L160', '[' + str(ind) + ']')[::-1]
    
    
    def frc_sst(self, ind):
        '''
        sea surface temperature (K)
        '''
        return self.read_nc('TMP_L1', '[' + str(ind) + ']')[::-1]
    
    
    def frc_uspd(self, ind):
        '''
        u 10-m wind speed (m s-1)
        '''
        return self.read_nc('U_GRD_L103_Avg', '[' + str(ind) + ']')[::-1]
    
    
    def frc_vspd(self, ind):
        '''
        v 10-m wind speed (m s-1)
        '''
        return self.read_nc('V_GRD_L103_Avg', '[' + str(ind) + ']')[::-1]


    def frc_shf(self, ind):
        '''
        net surface heat flux (W m-2)
        '''
        return self.read_nc('LHTFL_L1', '[' + str(ind) + ']')[::-1]

        
    def frc_shflux_SW_up(self, ind):
        '''
        upward shortwave radiation flux (W m-2)
        '''
        return self.read_nc('USWRF_L1', '[' + str(ind) + ']')[::-1]        
        
        
    def frc_shflux_SW_down(self, ind):
        '''
        downward shortwave radiation flux (W m-2)
        '''
        return self.read_nc('DSWRF_L1', '[' + str(ind) + ']')[::-1]  
        

    def frc_shflux_LW_up(self, ind):
        '''
        upward longwave radiation flux (W m-2)
        '''
        return self.read_nc('ULWRF_L1', '[' + str(ind) + ']')[::-1]
    
    
    def frc_shflux_LW_down(self, ind):
        '''
        downward longwave radiation flux (W m-2)
        '''
        return self.read_nc('DLWRF_L1', '[' + str(ind) + ']')[::-1]
        

    def frc_shflux_LH(self, ind):
        '''
        latent heat (W m-2)
        '''
        return self.read_nc('LHTFL_L1', '[' + str(ind) + ']')[::-1]
    
    
    def frc_shflux_SH(self, ind):
        '''
        sensible heat (W m-2)
        '''
        return self.read_nc('SHTFL_L1', '[' + str(ind) + ']')[::-1]
    
    
    def frc_qair(self, ind):
        '''
        sea level specific humidity (kg kg-1)
        '''
        return self.read_nc('SPF_H_L103', '[' + str(ind) + ']')[::-1]


    def frc_rel_hum(self, ind):
        '''
        relative humidity (%)
        '''
        return self.read_nc('R_H_L103', '[' + str(ind) + ']')[::-1]


    def vd_time(self):
        '''
        valid date and time as YYYYMMDDHH
        '''
        return self.read_nc('valid_date_time')
        
        
    def time(self):
        '''
        Hours since 1979-01-01 00:00:00.0 +0:00
        '''
        return self.read_nc('time')
        
    
    def get_mask(self):
        '''
        Return a land sea mask
        '''
        try:
            result = self.read_nc('LAND_L1', '[0,::-1]')
            return np.abs(result - 1.)
            
        except Exception:
            try:
                result = self.read_nc('LAND_L1_Avg', '[0,::-1]')
                return np.abs(result - 1.)
            except Exception:

                try:
	            result = self.read_nc('SALTY_L160', '[0,::-1]')
                    return np.abs(result.mask - 1.)
                except Exception, err:
                    print 'undefined grid'
        
        
    
    def dQdSST(self, sst, sat, rho_air, U, qsea):
        '''
        Compute the kinematic surface net heat flux sensitivity to the
        the sea surface temperature: dQdSST.
        Q_model ~ Q + dQdSST * (T_model - SST)
        dQdSST = - 4 * eps * stef * T^3  - rho_air * Cp * CH * U
                 - rho_air * CE * L * U * 2353 * ln (10 * q_s / T^2)
    
        Input parameters:
        sst     : sea surface temperature (Celsius)
        sat     : sea surface atmospheric temperature (Celsius)
        rho_air : atmospheric density (kilogram meter-3) 
        U       : wind speed (meter s-1)
        qsea    : sea level specific humidity (kg/kg)
 
        Output:
        dqdsst  : kinematic surface net heat flux sensitivity to the
                  the sea surface temperature (Watts meter-2 Celsius-1)
              
        From Roms_tools of Penven etal
        '''
        #  Specific heat of atmosphere.
        Cp = 1004.8
        # Sensible heat transfer coefficient (stable condition)
        Ch = 0.66e-3
        # Latent heat transfer coefficient (stable condition)
        Ce = 1.15e-3
        # Emissivity coefficient
        eps = 0.98
        # Stefan constant
        stef = 5.6697e-8
        # SST (Kelvin)
        SST = sst + 273.15
        #  Latent heat of vaporisation (J.kg-1)
        L = 2.5008e6 - 2.3e3 * sat
        # Infrared contribution
        q1 = -4. * stef * np.power(SST, 3)
        # Sensible heat contribution
        q2 = -rho_air * Cp * Ch * U
        # Latent heat contribution
        dqsdt = 2353. * np.log(10.) * qsea / np.power(SST, 2)
        q3 = -rho_air * Ce * L * U * dqsdt
        dQdSST = q1 + q2 + q3
        return dQdSST
    
    """
    def get_W3(self, roms_tools_W3, uspd_pts, uspd_mask):
        '''
        Get monthly point means of Roms_tools W3 over the CFSR domain
        '''
    """ 
    


class AirSea(object):
    '''
    
    '''
    def __init__(self):
        '''
        Constants from:
          http://woodshole.er.usgs.gov/operations/sea-mat/air_sea-html/as_consts.html
        '''
        # ------- physical constants
        self.g = 9.8 # acceleration due to gravity [m/s^2]
        self.eps_air = 0.62197 # molecular weight ratio (water/air)
        self.CtoK = 273.15 # conversion factor for [C] to [K]
        self.gas_const_R = 287.04 # gas constant for dry air [J/kg/K]
        
        # ------- meteorological constants
        self.z              = 10.    # default measurement height [m]
        self.kappa          = 0.4    # von Karman's constant
        self.Charnock_alpha = 0.011  # Charnock constant (for determining roughness length
        '''                            at sea given friction velocity), used in Smith
                                       formulas for drag coefficient and also in Fairall
                                       and Edson.  use alpha=0.011 for open-ocean and
                                       alpha=0.018 for fetch-limited (coastal) regions.'''
        self.R_roughness   = 0.11    # limiting roughness Reynolds # for aerodynamically
        '''                            smooth flow'''
        
        # ------ defaults suitable for boundary-layer studies  
        self.cp            = 1004.7   # heat capacity of air [J/kg/K]
        self.rho_air       = 1.22     # air density (when required as constant) [kg/m^2]
        self.Ta            = 10. # default air temperature [C]
        self.Pa            = 1020. # default air pressure for Kinneret [mbars]
        self.psych_default = 'screen' # default psychmometer type (see relhumid.m)
         # satur. specific humidity coefficient reduced by 2% over salt water
        self.Qsat_coeff    = 0.98


    def viscair(self):
        '''
        vis=VISCAIR(Ta) computes the kinematic viscosity of dry air as a
        function of air temperature following Andreas (1989), CRREL Report
        89-11.

        INPUT:   Ta  -  air temperature  [C]

        OUTPUT:  vis  -  air viscosity  [m^2/s]
        '''
        return 1.326e-5 * (1 + 6.542e-3 * self.Ta + 8.301e-6 * np.power(self.Ta, 2) - 
                                                 4.84e-9 * np.power(self.Ta, 3))
    
    
    def cdntc(self, sp):
        '''
        cd, u10 = cdntc(sp, z ,Ta) computes the neutral drag coefficient and
        wind speed at 10m given the wind speed and air temperature at height z
        following Smith (1988), J. Geophys. Res., 93, 311-326.
    
        INPUT:   sp - wind speed  [m/s]
             self.z - measurement height [m]
            self.Ta - air temperature (optional)  [C]
    
        OUTPUT:  cd - neutral drag coefficient at 10m
                  u10 - wind speed at 10m  [m/s]
        ''' 
        sp = np.asarray(sp)
        
        # iteration endpoint
        tol = np.asarray(.00001)
     
        visc = self.viscair()
     
        # remove any sp==0 to prevent division by zero
        np.place(sp, sp == 0, 0.1)
        
        # initial guess
        ustaro = np.zeros(sp.shape)
        ustarn = .036 * sp
     
        # iterate to find z0 and ustar
        ii = np.abs(ustarn - ustaro) > tol
    
        while np.any(ii):
            ustaro = ustarn
            z0 = self.Charnock_alpha * np.power(ustaro, 2) / self.g + \
                 self.R_roughness * visc / ustaro
            ustarn = sp * (self.kappa / np.log(self.z / z0))
            ii = np.abs(ustarn - ustaro) > tol
     
        sqrcd = self.kappa / np.log((10.) / z0)
        cd = np.power(sqrcd, 2)
    
        u10 = ustarn / sqrcd

        return cd, u10
        
        
    def stresstc(self, u, v, Ta=None, rho_air=None):
        '''
        taux, tauy = stresstc(u, v) computes the neutral wind stress given the
        wind speed and air temperature at height z following Smith (1988),
        J. Geophys. Res., 93, 311-326. Air temperature and density are optional
        inputs.

        INPUT:  u, v  - wind speed components   [m/s]
                z     - measurement height  [m]
                Ta    - air temperature (optional) [C]
                rho_air  - air density (optional)  [kg/m^3]

        OUTPUT: taux, tauy - wind stress components  [N/m^2]
        Adapted from http://woodshole.er.usgs.gov/operations/sea-mat/air_sea-html/as_consts.html
        '''
        sp = np.hypot(u, v)
        
        if Ta is not None:
            self.Ta = Ta
            
        cd, u10 = self.cdntc(sp)
        
        if rho_air is None:
            taux = self.rho_air * cd * u * u10
            tauy = self.rho_air * cd * v * u10
        else:
            taux = rho_air * cd * u * u10
            tauy = rho_air * cd * v * u10
        return taux, tauy



    def air_dens(self, Ta, RH, Pa=None, Q=None):
        '''
        rhoa=AIR_DENS(Ta,RH,Pa) computes the density of moist air.
        Air pressure is optional.

        INPUT:   Ta  - air temperature Ta  [C]
                 RH  - relative humidity  [%]
                 Pa  - air pressure (optional) [mb]

        OUTPUT:  rhoa - air density  [kg/m^3]
        '''
        if Pa is not None:
            self.Pa = Pa # pressure in mb
        
        if Q is None:
            Q = (0.01 * RH) * self.qsat(Ta, Pa) # specific humidity of air [kg/kg]
        
        o61  = 1. / self.eps_air - 1. # 0.61 (moisture correction for temp.)
        T    = Ta + self.CtoK # convert to K
        Tv   = T * (1. + o61 * Q) # air virtual temperature
        rhoa = (100. * self.Pa) / (self.gas_const_R * Tv) # air density [kg/m^3]
        return rhoa


    def qsat(self, Ta, Pa=None):
        '''
        QSAT: computes specific humidity at saturation.
        q=QSAT(Ta) computes the specific humidity (kg/kg) at saturation at
        air temperature Ta (deg C). Dependence on air pressure, Pa, is small,
        but is included as an optional input.

          INPUT:   Ta - air temperature  [C]
                   Pa - (optional) pressure [mb]
          
           OUTPUT:  q  - saturation specific humidity  [kg/kg]

        Version 1.0 used Tetens' formula for saturation vapor pressure
        from Buck (1981), J. App. Meteor., 1527-1532.  This version
        follows the saturation specific humidity computation in the COARE
        Fortran code v2.5b.  This results in an increase of ~5% in
        latent heat flux compared to the calculation with version 1.0.
        '''

        if Pa is not None:
            self.Pa = Pa # pressure in mb

        # as in Fortran code v2.5b for COARE
        ew = 6.1121 * (1.0007 + 3.46e-6 * self.Pa) * np.exp((17.502 * Ta) / \
             (240.97 + Ta)) # in mb
        q  = 0.62197 * (ew / (self.Pa - 0.378 * ew)) # mb -> kg/kg
        return q
        
        
    def delq(self, Ts, Ta, rh, Pa=None):
        '''
        dq=DELQ(Ts,Ta,rh) computes the specific humidity (kg/kg) difference
        between the air (as determined by relative humidty rh and air
        temperature Ta measurements) and the sea surface (where q is
        assumed to be at 98% saturation at the sea surface temperature Ts).
        DELQ uses QSAT based on Tetens' formula for saturation vapor
        pressure from Buck (1981), J. App. Meteor., 1527-1532.  The
        dependence of QSAT on pressure is small (<0.5%) and has been
        removed using a mean pressure of 1020 mb.

            INPUT:   Ts - sea surface temperature  [C]
                     Ta - air temperature  [C]
                     rh - relative humidity  [%]
                     Pa - (optional) pressure [mb]

            OUTPUT:  dq - air-sea specific humidity difference  [kg/kg]
        '''
        if Pa is not None:
            self.Pa = Pa # pressure in mb
        
        dq = 0.01 * rh * self.qsat(Ta, self.Pa) - \
             self.Qsat_coeff * self.qsat(Ts, self.Pa)
        return dq





if __name__ == '__main__':
    
    '''
    pycfsr2frc

    Prepare interannual ROMS surface forcing with CFSR data from
    
      http://rda.ucar.edu/pub/cfsr.html
    
    CFSR surface data for ROMS forcing are global but subgrids can be
    selected. User must supply a list of the files available, pycfsr2frc
    will loop through the list, sampling and interpolating each variable.
    ROMS needs the following variables:
      EP : evaporation - precipitation
      
      Net heat flux
          Qnet = SW - LW - LH - SH
      where SW denotes net downward shortwave radiation,
            LW net downward longwave radiation,
            LH latent heat flux,
        and SH sensible heat flux
    
    Note that there are dependencies for:
      dQdSS <- 
    
    CFSR grids, for info see http://rda.ucar.edu/datasets/ds093.2/docs/moly_filenames.html
        Horizontal resolution indicator, 4th character of filename:
        h - high (0.5-degree) resolution
        a - high (0.5-degree) resolution, spl type only
        f - full (1.0-degree) resolution
        l - low (2.5-degree) resolution
      But some files labelled 'l' are in fact 0.3-degree, eg, UWND, VWND...
    
    Notes about the data quality:
    1) The 0.3deg flxf06.gdas.DSWRF.SFC.grb2.nc is ugly
    
    
    Evan Mason, IMEDEA, 2012
    '''
    

    #_USER DEFINED VARIABLES_______________________________________
    
    # CFSR information_________________________________
    #cfsr_dir = '/Users/emason/toto/'
    #cfsr_dir = '/shared/emason/NCEP-CFSR/'
    cfsr_dir = '/shared/emason/NCEP-CFSR/S-14_N56__W-63_E12/'
    
    
    # Filenames of needed CFSR variables
    SSS            = 'ocnh01.gdas.SALTY.5m.grb2.nc'
    swflux         = 'ocnh01.gdas.EMNP.SFC.grb2.nc'
    shflux_SW_down = 'flxl01.gdas.DSWRF.SFC.grb2.nc'
    shflux_SW_up   = 'flxl01.gdas.USWRF.SFC.grb2.nc'
    shflux_LW_down = 'flxl01.gdas.DLWRF.SFC.grb2.nc'
    shflux_LW_up   = 'flxl01.gdas.ULWRF.SFC.grb2.nc'
    shflux_LH      = 'flxl01.gdas.LHTFL.SFC.grb2.nc'
    shflux_SH      = 'flxl01.gdas.SHTFL.SFC.grb2.nc'
    #sustr          = 'flxf01.gdas.UWND.10m.grb2.nc' # use for MedSea
    #svstr          = 'flxf01.gdas.VWND.10m.grb2.nc' # use for MedSea
    sustr          = 'flxf01.gdas.WND.10m.grb2.nc' # use for NEA
    svstr          = 'flxf01.gdas.WND.10m.grb2.nc' # use for NEA
    #SST            = 'pgbh01.gdas.TMP.SFC.grb2.nc' # use for MedSea
    SST            = 'ocnh01.gdas.TMP.SFC.grb2.nc' # use for NEA
    # Surface air temperature
    # file 'flxf01.gdas.TMP.2m.grb2.nc' compares well with Roms_tools sat.cdf
    #sat            = 'flxf01.gdas.TMP.2m.grb2.nc' # use for MedSea
    sat            = 'pgbh01.gdas.TMP.2m.grb2.nc' # use for NEA
    # Relative humidity
    # file 'pgbh01.gdas.R_H.2m.grb2.nc' compares well with Roms_tools rh.cdf
    rel_hum        = 'pgbh01.gdas.R_H.2m.grb2.nc'
    #sap            = 'pgbhnl.gdas.PRES.SFC.grb2.nc' # use for MedSea
    sap            = 'flxf01.gdas.PRES.SFC.grb2.nc' # use for NEA
    qair           = 'flxf01.gdas.SPF_H.2m.grb2.nc'
    
    # Filenames of masks for the 1.0, 0.5 and 0.3 degree grids
    mask10  = 'pgbl01.gdas.LAND.SFC.grb2.nc'
    mask05  = 'pgbh01.gdas.LAND.SFC.grb2.nc'
    mask03  = 'flxf01.gdas.LAND.SFC.grb2.nc'
    mask1_8 = 'flxl01.gdas.LAND.SFC.grb2.nc'
    maskocn = 'ocnh01.gdas.SALTY.5m.grb2.nc'

    
    
    # ROMS configuration information_________________________________
    
    #roms_dir = '/marula/emason/runs2012/MedSea15/'
    #roms_dir = '/shared/emason/marula/emason/runs2012/MedSea5/'
    #roms_dir = '/home/emason/runs2012_tmp/MedSea5_R2.5/'
    #roms_dir = '/marula/emason/runs2013/na_7pt5km_intann_5day/'
    #roms_dir = '/Users/emason/toto/'
    roms_dir = '/marula/emason/runs2013/cb_3km_2013_intann/'

    #roms_grd = 'grd_MedSea5_R2.5.nc'
    #roms_grd = 'roms_grd_NA2009_7pt5km.nc'
    roms_grd = 'cb_2009_3km_grd_smooth.nc'
    
    # Forcing file
    #frc_filename = 'frc_intann_MedSea5.nc' # ini filename
    #frc_filename = 'frc_CFSR_NA_7pt5km.nc'
    frc_filename = 'frc_2013_cb3km_CFSR.nc'

    # True if the frc file being prepared is for a downscaled simulation
    downscaled = True
    if downscaled:
        # Point to parent directory, where pyccmp2frc expects to find 
        # start_date.mat (created by set_ROMS_interannual_start.py)
        par_dir = '/marula/emason/runs2013/na_7pt5km_intann_5day/'

    # Start and end dates of the ROMS simulation
    # must be strings, format 'YYYYMMDDHH'
    #start_date = '1985010100'
    #end_date   = '2010010100'
    start_date = '1997010100'
    end_date   = '2000123100'


    
    # Flag to 360-day years
    make360 = False
    
    
    cycle_length = 0


    # Option for river runoff climatology
    #   Note, a precomputed *coast_distances.mat* must be available
    #   in roms_dir; this is computed using XXXXXX.py
    add_dai_runoff = True # True of False
    if add_dai_runoff:
        dai_file = '/home/emason/matlab/runoff/dai_runoff_mon_-180+180.nc'
        #dai_file = '/home/emason/matlab/runoff/dai_runoff_mon_0_360.nc'
    
    
    # interpolation / processing parameters_________________________________
    
    balldist = 250000. # distance (m) for kde_ball (should be 2dx at least?)
    
    # Filling of landmask options
    # Set to True to extrapolate sea data over land
    wind_fill_mask    = False # 10 m
    sat_fill_mask     = True # 2 m
    rel_hum_fill_mask = True # 2 m
    qair_fill_mask    = True # 2 m
    
    windspd_fill_mask = True # surface
    
    """
    # Use climatological scalar wind from Roms_tools for dQdSST calculation
    use_roms_tools_W3 = True
    if use_roms_tools_W3:
        roms_tools_W3 = '/home/emason/roms/Roms_tools/COADS05/w3.cdf'
    """

    #_END USER DEFINED VARIABLES_______________________________________
    
    plt.close('all')
    
    
    # This dictionary of CFSR files needs to supply some or all of the surface
    # forcing variables variables:
    cfsr_files = OrderedDict([
            ('SSS', SSS),
            ('swflux', swflux),
            ('shflux', OrderedDict([
              ('shflux_SW_down', shflux_SW_down),
              ('shflux_SW_up', shflux_SW_up),
              ('shflux_LW_down', shflux_LW_down),
              ('shflux_LW_up', shflux_LW_up),
              ('shflux_LH', shflux_LH),
              ('shflux_SH', shflux_SH)])),
           ('dQdSST', OrderedDict([
              ('sustr', sustr),
              ('svstr', svstr),
              ('SST', SST),
              ('sat', sat),
              ('rel_hum', rel_hum),
              ('sap', sap),
              ('qair', qair)]))])
    
    '''cfsr_files = OrderedDict([
                 ('SSS', SSS),
      ('dQdSST', OrderedDict([
              ('sustr', sustr),
              ('svstr', svstr),
              ('SST', SST),
              ('sat', sat),
              ('rel_hum', rel_hum),
              ('sap', sap),
              ('qair', qair)]))])'''
    
    
    # masks for the 1.0, 0.5 and 0.3 degree grids
    cfsr_masks = OrderedDict([
        ('mask10', mask10),
        ('mask05', mask05),
        ('mask03', mask03),
        ('maskocn', maskocn),
        ('mask1_8', mask1_8)])
    
    
    airsea = AirSea()
    
    dtstrdt = plt.datetime.datetime(np.int(start_date[:4]),
                                    np.int(start_date[4:6]),
                                    np.int(start_date[6:8]),
                                    np.int(start_date[8:10]))
    
    dtenddt = plt.datetime.datetime(np.int(end_date[:4]),
                                    np.int(end_date[4:6]),
                                    np.int(end_date[6:8]),
                                    np.int(end_date[8:10]))
    
    numrec = (dtenddt.year - dtstrdt.year) * 12 + dtenddt.month - dtstrdt.month + 1
    
    dtstr, dtend = plt.date2num(dtstrdt), plt.date2num(dtenddt)
    
    if downscaled:
        inidate = io.loadmat(par_dir + 'start_date.mat')
        deltaday0 = dtstr - inidate['start_date']
    
    # Initialise a RomsGrid object
    romsgrd = RomsGrid(''.join((roms_dir, roms_grd)))
    romsgrd.roms_dir = roms_dir
    
    # Create the forcing file
    romsgrd.create_frc_nc(''.join((roms_dir, frc_filename)),
                          start_date, end_date, numrec, cycle_length, 'pycfsr2frc')

    
    # Gnomonic projections for horizontal interpolations
    roms_M = romsgrd.get_gnom_trans()
    roms_points = romsgrd.proj2gnom(roms_M, no_mask=True) # we only want data points

    # Create ROMS grid KDE tree
    roms_tree = sp.KDTree(roms_points)
    
    
    # Get all CFSR mask and grid sizes
    mask10 = CfsrData(''.join((cfsr_dir, cfsr_masks['mask10'])))
    grid10 = CfsrGrid(''.join((cfsr_dir, cfsr_masks['mask10'])))
    mask05 = CfsrData(''.join((cfsr_dir, cfsr_masks['mask05'])))
    grid05 = CfsrGrid(''.join((cfsr_dir, cfsr_masks['mask05'])))
    mask03 = CfsrData(''.join((cfsr_dir, cfsr_masks['mask03'])))
    grid03 = CfsrGrid(''.join((cfsr_dir, cfsr_masks['mask03'])))
    maskocn = CfsrData(''.join((cfsr_dir, cfsr_masks['maskocn'])))
    gridocn = CfsrGrid(''.join((cfsr_dir, cfsr_masks['maskocn'])))
    mask1_8 = CfsrData(''.join((cfsr_dir, cfsr_masks['mask1_8'])))
    grid1_8 = CfsrGrid(''.join((cfsr_dir, cfsr_masks['mask1_8'])))
    
    # Arrays of masks and grids used by 'metrics' method
    masks = np.array([mask03, mask05, mask10, maskocn, mask1_8])
    grids = np.array([grid03, grid05, grid10, gridocn, grid1_8])
    
    
    # Loop over the CFSR files
    # Each CFSR file contains a different variable
    for cfsr_key, cfsr_file in zip(cfsr_files.keys(), cfsr_files.values()):
        
        # 'active' flag is True when looping through a desired time range
        flags = dict(active = False)
        
        
        if cfsr_key in 'shflux':
            cfsrgrd = CfsrGrid(''.join((cfsr_dir, cfsr_file['shflux_SW_down'])))
            cfsr_tree, cfsr_points_all = cfsrgrd.get_points_kdetree(roms_M)
        
        elif cfsr_key in 'dQdSST':
            # Using sustr here cos has highest resolution (0.3 deg.)
            cfsrgrd = CfsrGrid(''.join((cfsr_dir, cfsr_file['sustr'])))
            cfsr_tree, cfsr_points_all = cfsrgrd.get_points_kdetree(roms_M)
        
        else:
            cfsrgrd = CfsrGrid(''.join((cfsr_dir, cfsr_file)))
            cfsr_tree, cfsr_points_all = cfsrgrd.get_points_kdetree(roms_M)
    
        # set starting metrics for grid comparisons
        if cfsr_key == cfsr_files.keys()[0]:
            metrics = cfsrgrd.metrics()
        
        
        
        try:
            cfsr = CfsrData(''.join((cfsr_dir, cfsr_file)))
            print 'Opening file', ''.join((cfsr_dir, cfsr_file))
            
        except Exception:
            print 'Opening files at', cfsr_dir
            for value in cfsr_file.values():
                print '  ', value
                  
    
    

        
        # Note that a new ball will be created each time a different grid
        # is detected, as some of the CFSR variables may be on
        # different grids
        if np.alltrue(cfsr_key == cfsr_files.keys()[0] or metrics != cfsrgrd.metrics()):
            
            print '---compute a new kde ball (may take a while)'
            cfsr_ball = np.array(cfsr_tree.query_ball_tree(roms_tree, balldist)).nonzero()[0]
            print '---got kde ball'
            
            metrics = cfsrgrd.metrics()

            # Get cfsr_points covering subdomain only
            cfsr_points = np.array([cfsr_points_all[:,0].flat[cfsr_ball],
                                    cfsr_points_all[:,1].flat[cfsr_ball]]).T
            # Make new cfsr_tri that covers subdomain
            cfsr_tri = sp.Delaunay(cfsr_points)
    
            # Select appropriate mask for fillmask
            mask = cfsrgrd.select_mask(grids, masks)
        
        
        # Debug figure (this tests the query_ball_tree)
        if False:
            plt.figure()
            roms_M.scatter(cfsr_points_all[:,0], cfsr_points_all[:,1], c='g')
            roms_M.scatter(cfsr_points[:,0], cfsr_points[:,1], c='r')
            roms_M.drawcoastlines()
            rbx, rby = roms_M(romsgrd.boundary()[0], romsgrd.boundary()[1])
            roms_M.plot(rbx, rby)
            plt.title('KDE ball points for "%s"' %cfsr_key)
            plt.show()
        

        
        tind = 0       
    
        # loop over the time records in the file
        for cfsri, cfsrt in enumerate(cfsr.vd_time()):

            
            if np.logical_and(
                  np.int(cfsr.vd_time()[cfsri].tostring()) >= np.int(start_date),
                  np.int(cfsr.vd_time()[cfsri].tostring())  < np.int(end_date)):
                flags['active'] = True
            else:
                flags['active'] = False


            if flags['active']:
                
                dt = plt.datetime.datetime(np.int(cfsrt.tostring()[:4]),
                                           np.int(cfsrt.tostring()[4:6]),
                                           np.int(cfsrt.tostring()[6:8]),
                                           np.int(cfsrt.tostring()[8:10]))
                #print 'dt.month',dt.month
                dtnum = plt.date2num(dt)



                # Evaporation - precipitation
                if 'swflux' in cfsr_key: # E - P
                    
                    # Fill the mask
                    if flags.has_key('swflux_wt'):
                        swflux = cfsr.fillmask(cfsr.frc_emp(cfsri), swflux_mask, flags['swflux_wt'])
                    else:
                        swflux_mask = cfsrgrd.select_mask(grids, masks)
                        swflux, flags['swflux_wt'] = cfsr.fillmask(cfsr.frc_emp(cfsri), swflux_mask)
                    
                    cfsrdata = swflux
                    cfsr.out_var = 'swflux'
                    cfsr.out_time = 'swf_time'


                # Sea surface salinity
                elif 'SSS' in cfsr_key: # surface salinity (in fact 5m)
                    
                    # Fill the mask
                    if flags.has_key('sss_wt'):
                        sss = cfsr.fillmask(cfsr.frc_sss(cfsri), sss_mask, flags['sss_wt'])
                    else:
                        sss_mask = cfsrgrd.select_mask(grids, masks)
                        sss, flags['sss_wt'] = cfsr.fillmask(cfsr.frc_sss(cfsri), sss_mask)
                    
                    cfsrdata = sss * 1e3
                    cfsr.out_var = 'SSS'
                    cfsr.out_time = 'sss_time'
                    
                
                # net heat flux
                elif 'shflux' in cfsr_key:
                    #---------------------------------------------
                    ''' Net Heat Flux (shflux)
                    Note, Net heat flux is computed as:
                      Qnet = SW - LW - LH - SH
                      where SW : net downward shortwave radiation
                                     (upward - downward)
                            LW : net downward longwave radiation
                                     (upward - downward)
                            LH : latent heat flux,
                            SH : sensible heat flux.
                    These should all be on the same grid'''
                    #---------------------------------------------
                    # Short wave down
                    if 'swd_filename' in locals():
                        swd = swd_data.fillmask(swd_data.frc_shflux_SW_down(cfsri), swd_mask, flags['swd_wt'])
                    else:
                        swd_filename = ''.join((cfsr_dir, cfsr_file['shflux_SW_down']))
                        swd_data = CfsrData(swd_filename)
                        swd = swd_data.frc_shflux_SW_down(cfsri)
                        swd_grid = CfsrGrid(swd_filename)
                        swd_mask = swd_grid.select_mask(grids, masks)
                        swd, flags['swd_wt'] = swd_data.fillmask(swd, swd_mask)
                        swd_points_all = swd_grid.get_points_kdetree(roms_M)[-1]
                        swd_tri = sp.Delaunay(swd_points_all)
                        swd_pts = swd_grid.get_points(roms_M)

                    
                    # Short wave up
                    if 'swu_filename' in locals():
                        swu = swu_data.fillmask(swu_data.frc_shflux_SW_up(cfsri), swu_mask, flags['swu_wt'])
                    else:
                        swu_filename = ''.join((cfsr_dir, cfsr_file['shflux_SW_up']))
                        swu_data = CfsrData(swu_filename)
                        swu = swu_data.frc_shflux_SW_up(cfsri)
                        swu_grid = CfsrGrid(swu_filename)
                        swu_mask = swu_grid.select_mask(grids, masks)
                        swu, flags['swu_wt'] = swu_data.fillmask(swu, swu_mask)
                        swu_points_all = swu_grid.get_points_kdetree(roms_M)[-1]
                        swu_tri = sp.Delaunay(swu_points_all)
                        swu_pts = swu_grid.get_points(roms_M)

                    
                    # Long wave down
                    if 'lwd_filename' in locals():
                        lwd = lwd_data.fillmask(lwd_data.frc_shflux_LW_down(cfsri), lwd_mask, flags['lwd_wt'])
                    else:
                        lwd_filename = ''.join((cfsr_dir, cfsr_file['shflux_LW_down']))
                        lwd_data = CfsrData(lwd_filename)
                        lwd = lwd_data.frc_shflux_LW_down(cfsri)
                        lwd_grid = CfsrGrid(lwd_filename)
                        lwd_mask = lwd_grid.select_mask(grids, masks)
                        lwd, flags['lwd_wt'] = lwd_data.fillmask(lwd, lwd_mask)
                        lwd_points_all = lwd_grid.get_points_kdetree(roms_M)[-1]
                        lwd_tri = sp.Delaunay(lwd_points_all)
                        lwd_pts = lwd_grid.get_points(roms_M)
                        

                    # Long wave up
                    if 'lwu_filename' in locals():
                        lwu = lwu_data.fillmask(lwu_data.frc_shflux_LW_up(cfsri), lwu_mask, flags['lwu_wt'])
                    else:
                        lwu_filename = ''.join((cfsr_dir, cfsr_file['shflux_LW_up']))
                        lwu_data = CfsrData(lwu_filename)
                        lwu = lwu_data.frc_shflux_LW_up(cfsri)
                        lwu_grid = CfsrGrid(lwu_filename)
                        lwu_mask = lwu_grid.select_mask(grids, masks)
                        lwu, flags['lwu_wt'] = lwu_data.fillmask(lwu, lwu_mask)
                        lwu_points_all = lwu_grid.get_points_kdetree(roms_M)[-1]
                        lwu_tri = sp.Delaunay(lwu_points_all)
                        lwu_pts = lwu_grid.get_points(roms_M)

                    # Latent heat
                    if 'lh_filename' in locals():
                        lh = lh_data.fillmask(lh_data.frc_shflux_LH(cfsri), lh_mask, flags['lh_wt'])
                    else:
                        lh_filename = ''.join((cfsr_dir, cfsr_file['shflux_LH']))
                        lh_data = CfsrData(lh_filename)
                        lh = lh_data.frc_shflux_LH(cfsri)
                        lh_grid = CfsrGrid(lh_filename)
                        lh_mask = lh_grid.select_mask(grids, masks)
                        lh, flags['lh_wt'] = lh_data.fillmask(lh, lh_mask)
                        lh_points_all = lh_grid.get_points_kdetree(roms_M)[-1]
                        lh_tri = sp.Delaunay(lh_points_all)
                        lh_pts = lh_grid.get_points(roms_M)
                        
                    # Sensible heat
                    if 'sh_filename' in locals():
                        sh = sh_data.fillmask(sh_data.frc_shflux_SH(cfsri), sh_mask, flags['sh_wt'])
                    else:
                        sh_filename = ''.join((cfsr_dir, cfsr_file['shflux_SH']))
                        sh_data = CfsrData(sh_filename)
                        sh = sh_data.frc_shflux_SH(cfsri)
                        sh_grid = CfsrGrid(sh_filename)
                        sh_mask = sh_grid.select_mask(grids, masks)
                        sh, flags['sh_wt'] = sh_data.fillmask(sh, sh_mask)
                        sh_points_all = sh_grid.get_points_kdetree(roms_M)[-1]
                        sh_tri = sp.Delaunay(sh_points_all)
                        sh_pts = sh_grid.get_points(roms_M)
                         

                    # Get Qnet
                    # net shortwave = swd - swu
                    # net longwave = lwu - lwd
                    cfsrdata = (swd - swu) - (lwu - lwd) - lh - sh
                    cfsr.out_var = cfsr_key
                    cfsr.out_time = 'shf_time'
                    
                    # Interpolate swd to ROMS grid
                    swd = horizInterp(cfsr_tri, swd.flat[cfsr_ball])(roms_points)
                    cfsrdata_out = np.zeros_like(romsgrd.mask().ravel())
                    cfsrdata_out[np.nonzero(romsgrd.mask().ravel())[0]] = swd
                    swd = cfsrdata_out.reshape(romsgrd.mask().shape)



                elif 'dQdSST' in cfsr_key:
                    
                    
                    # U wind speed
                    if 'uspd_filename' in locals():
                        uspd = uspd_data.frc_uspd(cfsri)
                        if wind_fill_mask:
                            uspd = uspd_data.fillmask(uspd, uspd_mask, flags['uspd_wt'])
                        scalar_u = uspd.copy()
                    else:
                        uspd_filename = ''.join((cfsr_dir, cfsr_file['sustr']))
                        uspd_data = CfsrData(uspd_filename)
                        uspd = uspd_data.frc_uspd(cfsri)
                        scalar_u = uspd.copy()
                        uspd_grid = CfsrGrid(uspd_filename)
                        if wind_fill_mask:
                            uspd_mask = uspd_grid.select_mask(grids, masks)
                            uspd, flags['uspd_wt'] = uspd_data.fillmask(uspd, uspd_mask)
                        uspd_points_all = uspd_grid.get_points_kdetree(roms_M)[-1]
                        uspd_tri = sp.Delaunay(uspd_points_all)
                        uspd_pts = grid03.get_points(roms_M)
                    # Check if we need to interpolate to 0.3 deg grid
                    if not np.alltrue(uspd_grid.metrics() == grid03.metrics()):
                        print '--- interpolating USPD to 0.3 deg grid'
                        uspd = horizInterp(uspd_tri, uspd.ravel())(uspd_pts)
                        uspd = uspd.reshape(grid03.lon().shape)
                    
                    
                    # V wind speed
                    if 'vspd_filename' in locals():
                        vspd = vspd_data.frc_vspd(cfsri)
                        if wind_fill_mask:
                            vspd = vspd_data.fillmask(vspd, vspd_mask, flags['vspd_wt'])
                        scalar_v = vspd.copy()
                    else:
                        vspd_filename = ''.join((cfsr_dir, cfsr_file['svstr']))
                        vspd_data = CfsrData(vspd_filename)
                        vspd = vspd_data.frc_vspd(cfsri)
                        scalar_v = vspd.copy()
                        vspd_grid = CfsrGrid(vspd_filename)
                        if wind_fill_mask:
                            vspd_mask = vspd_grid.select_mask(grids, masks)
                            vspd, flags['vspd_wt'] = vspd_data.fillmask(vspd, vspd_mask)
                        vspd_points_all = vspd_grid.get_points_kdetree(roms_M)[-1]
                        vspd_tri = sp.Delaunay(vspd_points_all)
                        vspd_pts = grid03.get_points(roms_M)
                    # Check if we need to interpolate to 0.3 deg grid
                    if not np.alltrue(vspd_grid.metrics() == grid03.metrics()):
                        print '--- interpolating VSPD to 0.3 deg grid'
                        vspd = horizInterp(vspd_tri, vspd.ravel())(vspd_pts)
                        vspd = vspd.reshape(grid03.lon().shape)
                    
                    
                    # Sea surface temperature
                    if 'sst_filename' in locals():
                        sst = sst_data.fillmask(sst_data.frc_sst(cfsri), sst_mask, flags['sst_wt'])
                    else:
                        sst_filename = ''.join((cfsr_dir, cfsr_file['SST']))
                        sst_data = CfsrData(sst_filename)
                        sst = sst_data.frc_sst(cfsri)
                        sst_grid = CfsrGrid(sst_filename)
                        sst_mask = sst_grid.select_mask(grids, masks)
                        sst, flags['sst_wt'] = sst_data.fillmask(sst, sst_mask)
                        sst_points_all = sst_grid.get_points_kdetree(roms_M)[-1]
                        sst_tri = sp.Delaunay(sst_points_all)
                        sst_pts = grid03.get_points(roms_M)
                    # Check if we need to interpolate to 0.3 deg grid
                    if not np.alltrue(sst_grid.metrics() == grid03.metrics()):
                        print '--- interpolating SST to 0.3 deg grid'
                        sst = horizInterp(sst_tri, sst.ravel())(sst_pts)
                        sst = sst.reshape(grid03.lon().shape)
                    
                    
                    # Specific humidity
                    if 'qair_filename' in locals():
                        qair = qair_data.frc_qair(cfsri)
                        if qair_fill_mask:
                            qair = qair_data.fillmask(qair_data.frc_qair(cfsri), qair_mask, flags['qair_wt'])
                    else:
                        qair_filename = ''.join((cfsr_dir, cfsr_file['qair']))
                        qair_data = CfsrData(qair_filename)
                        qair = qair_data.frc_qair(cfsri)
                        qair_grid = CfsrGrid(qair_filename)
                        if qair_fill_mask:
                            qair_mask = qair_grid.select_mask(grids, masks)
                            qair, flags['qair_wt'] = qair_data.fillmask(qair, qair_mask)
                        qair_points_all = qair_grid.get_points_kdetree(roms_M)[-1]
                        qair_tri = sp.Delaunay(qair_points_all)
                        qair_pts = grid03.get_points(roms_M)
                    # Check if we need to interpolate to 0.3 deg grid
                    if not np.alltrue(qair_grid.metrics() == grid03.metrics()):
                        print '--- interpolating QAIR to 0.3 deg grid'
                        qair = horizInterp(qair_tri, qair.ravel())(qair_pts)
                        qair = qair.reshape(grid03.lon().shape)
                    
                    
                    # Surface air temperature
                    if 'sat_filename' in locals():
                        sat = sat_data.frc_sat(cfsri)
                        if sat_fill_mask:
                            sat = sat_data.fillmask(sat_data.frc_sat(cfsri), sat_mask, flags['sat_wt'])
                    else:
                        sat_filename = ''.join((cfsr_dir, cfsr_file['sat']))
                        sat_data = CfsrData(sat_filename)
                        sat = sat_data.frc_sat(cfsri)
                        sat_grid = CfsrGrid(sat_filename)
                        if sat_fill_mask:
                            sat_mask = sat_grid.select_mask(grids, masks)
                            sat, flags['sat_wt'] = sat_data.fillmask(sat, sat_mask)
                        sat_points_all = sat_grid.get_points_kdetree(roms_M)[-1]
                        sat_tri = sp.Delaunay(sat_points_all)
                        sat_pts = grid03.get_points(roms_M)
                    # Check if we need to interpolate to 0.3 deg grid
                    if not np.alltrue(sat_grid.metrics() == grid03.metrics()):
                        print '--- interpolating SAT to 0.3 deg grid'
                        sat = horizInterp(sat_tri, sat.ravel())(sat_pts)
                        sat = sat.reshape(grid03.lon().shape)
                        

                    # Surface air pressure
                    if 'sap_filename' in locals():
                        sap = sap_data.fillmask(sap_data.frc_sap(cfsri), sap_mask, flags['sap_wt'])
                    else:
                        sap_filename = ''.join((cfsr_dir, cfsr_file['sap']))
                        sap_data = CfsrData(sap_filename)
                        sap = sap_data.frc_sap(cfsri)
                        sap_grid = CfsrGrid(sap_filename)
                        sap_mask = sap_grid.select_mask(grids, masks)
                        sap, flags['sap_wt'] = sap_data.fillmask(sap, sap_mask)
                        sap_points_all = sap_grid.get_points_kdetree(roms_M)[-1]
                        sap_tri = sp.Delaunay(sap_points_all)
                        sap_pts = grid03.get_points(roms_M)
                    # Check if we need to interpolate to 0.3 deg grid
                    if not np.alltrue(sap_grid.metrics() == grid03.metrics()):
                        print '--- interpolating SAP to 0.3 deg grid'
                        sap = horizInterp(sap_tri, sap.ravel())(sap_pts)
                        sap = sap.reshape(grid03.lon().shape)


                    # Relative humidity
                    if 'rel_hum_filename' in locals():
                        rel_hum = rel_hum_data.frc_rel_hum(cfsri)
                        if rel_hum_fill_mask:
                            rel_hum = rel_hum_data.fillmask(rel_hum_data.frc_rel_hum(cfsri), rel_hum_mask, flags['rel_hum_wt'])
                    else:
                        rel_hum_filename = ''.join((cfsr_dir, cfsr_file['rel_hum']))
                        rel_hum_data = CfsrData(rel_hum_filename)
                        rel_hum = rel_hum_data.frc_rel_hum(cfsri)
                        rel_hum_grid = CfsrGrid(rel_hum_filename)
                        if rel_hum_fill_mask:
                            rel_hum_mask = rel_hum_grid.select_mask(grids, masks)
                            rel_hum, flags['rel_hum_wt'] = rel_hum_data.fillmask(rel_hum, rel_hum_mask)
                        rel_hum_points_all = rel_hum_grid.get_points_kdetree(roms_M)[-1]
                        rel_hum_tri = sp.Delaunay(rel_hum_points_all)
                        rel_hum_pts = grid03.get_points(roms_M)
                    # Check if we need to interpolate to 0.3 deg grid
                    if not np.alltrue(rel_hum_grid.metrics() == grid03.metrics()):
                        print '--- interpolating REL_HUM to 0.3 deg grid'
                        rel_hum = horizInterp(rel_hum_tri, rel_hum.ravel())(rel_hum_pts)
                        rel_hum = rel_hum.reshape(grid03.lon().shape)
                        
                        

                    
                    
                    # Prepare for dQdSST
                    if windspd_fill_mask:
                        windspd = np.hypot(scalar_u, scalar_v)
                    else:
                        windspd = np.hypot(uspd, vspd)
                    
                    sat -= airsea.CtoK # convert from K to C
                    sst -= airsea.CtoK # convert from K to C
                    sap /= 100. # convert from Pa to mb
                    
                    # Seems ok compared to Roms_tools airdens.cdf
                    rho_air = airsea.air_dens(sat, rel_hum, sap, qair)
                    #plt.pcolormesh(rho_air * sat_mask)
                    
                    # Speed to stress (Smith etal 1988)
                    sustr, svstr = airsea.stresstc(uspd, vspd, sat, rho_air)
                    
                    # Get qsea
                    dq = airsea.delq(sst, sat, rel_hum, sap)
                    qsea = qair - dq

                    #print 'WARNING: windspd *= 1.5'
                    #windspd *= 1.5


                    cfsrdata = cfsr.dQdSST(sst, sat, rho_air, windspd, qsea)
                    cfsr.out_var = cfsr_key
                    cfsr.out_time = 'sst_time'
                    
                    
                    # Interpolate sustr to ROMS grid
                    sustr = horizInterp(cfsr_tri, sustr.flat[cfsr_ball])(roms_points)
                    cfsrdata_out = np.zeros_like(romsgrd.mask().ravel())
                    cfsrdata_out[np.nonzero(romsgrd.mask().ravel())[0]] = sustr
                    sustr = cfsrdata_out.reshape(romsgrd.mask().shape)
                    
                    # Interpolate svstr to ROMS grid
                    svstr = horizInterp(cfsr_tri, svstr.flat[cfsr_ball])(roms_points)
                    cfsrdata_out = np.zeros_like(romsgrd.mask().ravel())
                    cfsrdata_out[np.nonzero(romsgrd.mask().ravel())[0]] = svstr
                    svstr = cfsrdata_out.reshape(romsgrd.mask().shape)
                    
                    # Interpolate SST to ROMS grid
                    sst = horizInterp(cfsr_tri, sst.flat[cfsr_ball])(roms_points)
                    cfsrdata_out = np.zeros_like(romsgrd.mask().ravel())
                    cfsrdata_out[np.nonzero(romsgrd.mask().ravel())[0]] = sst
                    sst = cfsrdata_out.reshape(romsgrd.mask().shape)
                    
   
                else:
                    raise KeyError("Key %s in 'cfsr_files' is suspect" %cfsr_key)
                

                
                # Interpolate to ROMS grid
                cfsrdatai = horizInterp(cfsr_tri, cfsrdata.flat[cfsr_ball])(roms_points)
                
                cfsrdata_out = np.zeros_like(romsgrd.mask().ravel())
                cfsrdata_out[np.nonzero(romsgrd.mask().ravel())[0]] = cfsrdatai
                cfsrdata_out = cfsrdata_out.reshape(romsgrd.mask().shape)
                
                
                # Figure for debugging
                if False and cfsri == 0:
                    cfsrx, cfsry = roms_M(cfsrgrd.lon(), cfsrgrd.lat())
                    plt.figure()
                    plt.subplot(121)
                    plt.title('Interpolated data (%s)' %cfsr_key)
                    rx, ry = roms_M(romsgrd.lon(), romsgrd.lat())
                    cfsrdata_out = np.ma.masked_where(romsgrd.mask() == 0,
                                                   cfsrdata_out)
                    roms_M.pcolormesh(rx, ry, cfsrdata_out)
                    plt.clim(cfsrdatai.min(), cfsrdatai.max())
                    plt.subplot(122)
                    plt.title('Raw data (%s)' %cfsr_key)
                    cfsrdata = np.ma.masked_where(cfsrmask == 0,
                                               cfsrdata)
                    roms_M.pcolormesh(cfsrx, cfsry, cfsrdata)
                    plt.clim(cfsrdatai.min(), cfsrdatai.max())
                    plt.colorbar()
                    rbx, rby = roms_M(romsgrd.boundary()[0], romsgrd.boundary()[1])
                    roms_M.plot(rbx, rby, 'k')
                    plt.show()
                    
                    
                    
                
                # Write to forcing file
                nc = netcdf.Dataset(romsgrd.frcfile, 'a')
        
                if 'dQdSST' in cfsr_key:
                    sustr, svstr = romsgrd.rotate(sustr, svstr, 1)
                    
                    sustr = romsgrd.rho2u_2d(sustr) * romsgrd.umask()
                    svstr = romsgrd.rho2v_2d(svstr) * romsgrd.vmask()
                    
                    nc.variables['sustr'][tind] = sustr
                    nc.variables['svstr'][tind] = svstr
                    nc.variables['SST'][tind] = sst
                
                elif 'shflux' in cfsr_key:
                    nc.variables['swrad'][tind] = swd
                
                
                # Add the Dai river climatology
                elif add_dai_runoff and 'swflux' in cfsr_key:
                    cfsrdata_out = romsgrd.get_runoff(cfsrdata_out, dai_file, dt.month)
                    
                    
                nc.variables[cfsr.out_var][tind] = cfsrdata_out
                
                
                
                
                # Flag if we want 360-day years...
                if make360:
                    # Probably not necessary, but trying to account for leap years
                    if ca.isleap(dt.year):
                        mk360day = 360 / 366.
                    else:
                        mk360day = 360 / 365.
                    theday = (dtnum - dtstr) * mk360day
                
                    theday += 15. # set to middle of month
                
                else:
                    mid_month = 0.5 * ca.monthrange(dt.year, dt.month)[1]
                    theday = dtnum - dtstr + mid_month
                
                # If 'downscaled' is True this will add the number of days between
                # ini time of the parent and ini time of the new solution
                theday += deltaday0
                
                nc.variables[cfsr.out_time][tind] = theday
                
                if 'dQdSST' in cfsr_key:
                    nc.variables['sms_time'][tind] = theday
                
                elif 'shflux' in cfsr_key:
                    nc.variables['srf_time'][tind] = theday
                
                if cycle_length == 0:
                    cyc_end = theday + 15.
                    nc.variables['sms_time'].cycle_length = cyc_end
                    nc.variables['shf_time'].cycle_length = cyc_end
                    nc.variables['swf_time'].cycle_length = cyc_end
                    nc.variables['sst_time'].cycle_length = cyc_end
                    nc.variables['srf_time'].cycle_length = cyc_end
                    nc.variables['sss_time'].cycle_length = cyc_end
                
                
                nc.variables['month'][tind] = dt.month
                
                nc.sync()
                
                nc.close()

                print '--date: %s, day: %s, record: %s' %(cfsrt.tostring(), np.float(theday), tind)
                tind += 1
                
                
                
            #if np.int(cfsrt.tostring()) > np.int(end_date):
                               
            #    flags['active'] = False
        print '--%s records written' %tind
    
    print '\nNow run scale_cfsr2coads.py to scale with COADS'